匹配中文字符的正则表达式：
 程序代码
[\u4e00-\u9fa5]

评注：匹配中文还真是个头疼的事，有了这个表达式就好办了

匹配双字节字符(包括汉字在内)：
 程序代码
[^\x00-\xff]

评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）

匹配空白行的正则表达式：
 程序代码
\n\s*\r

评注：可以用来删除空白行

匹配HTML标记的正则表达式：
 程序代码
<(\S*?)[^>]*>.*?|<.*? />

评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力

匹配首尾空白字符的正则表达式：
 程序代码
^\s*|\s*$

评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式

匹配Email地址的正则表达式：
 程序代码
\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

评注：表单验证时很实用

匹配网址URL的正则表达式：
 程序代码
[a-zA-z]+://[^\s]*

评注：网上流传的版本功能很有限，上面这个基本可以满足需求


匹配二级或多级域名的主域名
([a-z0-9][a-z0-9\-]*?\.(?:com|cn|net|org|gov|info|la|cc|co)(?:\.(?:cn|jp))?)$

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：
 程序代码
^[a-zA-Z][a-zA-Z0-9_]{4,15}$

评注：表单验证时很实用

匹配国内电话号码：
 程序代码
\d{3}-\d{8}|\d{4}-\d{7}

评注：匹配形式如 0511-4405222 或 021-87888822

匹配腾讯QQ号：
 程序代码
[1-9][0-9]{4,}

评注：腾讯QQ号从10000开始

匹配中国邮政编码：
 程序代码
[1-9]\d{5}(?!\d)

评注：中国邮政编码为6位数字

匹配身份证：
 程序代码
\d{15}|\d{18}

评注：中国的身份证为15位或18位

匹配ip地址：
 程序代码
\d+\.\d+\.\d+\.\d+

评注：提取ip地址时有用

匹配特定数字：

 程序代码
^[1-9]\d*$　 　 //匹配正整数
^-[1-9]\d*$ 　 //匹配负整数
^-?[1-9]\d*$　　 //匹配整数
^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数
^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数
^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）

评注：处理大量数据时有用，具体应用时注意修正

匹配特定字符串：

 程序代码
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串


在使用 RegularExPRessionValidator 验证控件时的验证功能及其验证表达式介绍如下:

只能输入数字：
 程序代码
^[0-9]*$

只能输入n位的数字：
 程序代码
^\d{n}$

只能输入至少n位数字：
 程序代码
^\d{n,}$

只能输入m-n位的数字：
 程序代码
^\d{m,n}$

只能输入零和非零开头的数字：
 程序代码
^(0|[1-9][0-9]*)$

只能输入有两位小数的正实数：
 程序代码
^[0-9]+(.[0-9]{2})?$

只能输入有1-3位小数的正实数：
 程序代码
^[0-9]+(.[0-9]{1,3})?$

只能输入非零的正整数：
 程序代码
^\+?[1-9][0-9]*$

只能输入非零的负整数：
 程序代码
^\-[1-9][0-9]*$

只能输入长度为3的字符：
 程序代码
^.{3}$

只能输入由26个英文字母组成的字符串：
 程序代码
^[A-Za-z]+$

只能输入由26个大写英文字母组成的字符串：
 程序代码
^[A-Z]+$

只能输入由26个小写英文字母组成的字符串：
 程序代码
^[a-z]+$

只能输入由数字和26个英文字母组成的字符串：
 程序代码
^[A-Za-z0-9]+$

只能输入由数字、26个英文字母或者下划线组成的字符串：
 程序代码
^\w+$

只能输入汉字：
 程序代码
^[\u4e00-\u9fa5],{0,}$

验证用户密码：
 程序代码
^[a-zA-Z]\w{5,17}$

正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。
验证是否含有^%&',;=?$\等字符：
 程序代码
[^%&',;=?$\x22]+ 

验证Email地址：
 程序代码
^\w+[-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$

验证InternetURL：
 程序代码
^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$

验证电话号码：
 程序代码
^(\(\d{3,4}\)|\d{3,4}-)?\d{7,8}$ 

正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX， XXX-XXXXXXXX，XXXXXXX，XXXXXXXX
验证身份证号（15位或18位数字）：
 程序代码
^\d{15}|\d{}18$

验证一年的12个月：
 程序代码
^(0?[1-9]|1[0-2])$

正确格式为：01-09和112
验证一个月的31天：
 程序代码
^((0?[1-9])|((1|2)[0-9])|30|31)$ 

正确格式为：0109和131

-----------------------常用的匹配正则表达式和实例--------------------------------

匹配中文字符的正则表达式： 
 程序代码
[\u4e00-\u9fa5]


匹配双字节字符(包括汉字在内)：
 程序代码
[^\x00-\xff]


应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）


 程序代码
String.prototype.len=function(){return this.replace([^\x00-\xff]/g,"aa").length;}


匹配空行的正则表达式：
 程序代码
\n[\s| ]*\r


匹配HTML标记的正则表达式：
 程序代码
/<(.*)>.*<\/\1>|<(.*) \/>/


匹配首尾空格的正则表达式：
 程序代码
(^\s*)|(\s*$)


应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：


 程序代码
String.prototype.trim = function()
{
return this.replace(/(^\s*)|(\s*$)/g, "");
}


利用正则表达式分解和转换IP地址：

下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：


 程序代码
function IP2V(ip)
{
re=/(\d+)\.(\d+)\.(\d+)\.(\d+)/g //匹配IP地址的正则表达式
if(re.test(ip))
{
return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1
}
else
{
throw new Error("Not a valid IP address!")
}
}


不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下：
http://bizhi.knowsky.com/

 程序代码
var ip="10.100.20.168"
ip=ip.split(".")
alert("IP值是："+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1))


匹配Email地址的正则表达式：
 程序代码
\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*


匹配网址URL的正则表达式：
 程序代码
http://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?


匹配区号、分机号的固定电话正则表达式：
 程序代码
/^((0\d{2,3})-)(\d{7,8})(-(\d{3,}))?$/


手机号码前面以1开头，第二位现在是3或者5，后面是9位数字，则：
 程序代码
/^1[35]\d{9}$/


更强悍的固定电话号码正则表达式：
 程序代码
(^(\d{2,4}[-_－―]?)?\d{3,8}([-_－―]?\d{3,8})?([-_－―]?\d{1,7})?$)|(^0?1[35]\d{9}$)

该表达式可以验证那些不小心把连接符“-”写出“－”的或者下划线“_”的等等。

利用正则表达式去除字串中重复的字符的算法程序：[注：此程序不正确，原因见本贴回复]


 程序代码
var s="abacabefgeeii"
var s1=s.replace(/(.).*\1/g,"$1")
var re=new RegExp("["+s1+"]","g")
var s2=s.replace(re,"")
alert(s1+s2) //结果为：abcefgi


我原来在CSDN上发贴寻求一个表达式来实现去除重复字符的方法，最终没有找到，这是我能想到的最简单的实现方法。思路是使用后向引用取出包括重复的字符，再以重复的字符建立第二个表达式，取到不重复的字符，两者串连。这个方法对于字符顺序有要求的字符串可能不适用。

得用正则表达式从URL地址中提取文件名的javascript程序，如下结果为page1


 程序代码
s="http://www.9499.net/page1.htm"
s=s.replace(/(.*\/){0,}([^\.]+).*/ig,"$2")
alert(s)


利用正则表达式限制网页表单里的文本框输入内容：

用正则表达式限制只能输入中文：
 程序代码
onkeyup="value=value.replace(/[^\u4E00-\u9FA5]/g,)" onbeforepaste="clipboardData.setData(text,clipboardData.getData(text).replace(/[^\u4E00-\u9FA5]/g,))"


用正则表达式限制只能输入全角字符： 
 程序代码
onkeyup="value=value.replace(/[^\uFF00-\uFFFF]/g,)" onbeforepaste="clipboardData.setData(text,clipboardData.getData(text).replace(/[^\uFF00-\uFFFF]/g,))"


用正则表达式限制只能输入数字：
 程序代码
onkeyup="value=value.replace(/[^\d]/g,) "onbeforepaste="clipboardData.setData(text,clipboardData.getData(text).replace(/[^\d]/g,))"


用正则表达式限制只能输入数字和英文：
 程序代码
onkeyup="value=value.replace(/[\W]/g,) "onbeforepaste="clipboardData.setData(text,clipboardData.getData(text).replace(/[^\d]/g,))"

 

 程序代码
^\d+$　　//匹配非负整数（正整数 + 0）
^[0-9]*[1-9][0-9]*$　　//匹配正整数
^((-\d+)|(0+))$　　//匹配非正整数（负整数 + 0）
^-[0-9]*[1-9][0-9]*$　　//匹配负整数
^-?\d+$　　　　//匹配整数
^\d+(\.\d+)?$　　//匹配非负浮点数（正浮点数 + 0）
^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$　　//匹配正浮点数
^((-\d+(\.\d+)?)|(0+(\.0+)?))$　　//匹配非正浮点数（负浮点数 + 0）
^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$　　//匹配负浮点数
^(-?\d+)(\.\d+)?$　　//匹配浮点数
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串
^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$　　　　//匹配email地址
^[a-zA-z]+://匹配(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$　　//匹配url


------------------------------------
利用正则表达式去除字串中重复的字符的算法程序：


 程序代码
var s="abacabefgeeii"
var s1=s.replace(/(.).*\1/g,"$1")
var re=new RegExp("["+s1+"]","g")
var s2=s.replace(re,"")
alert(s1+s2) //结果为：abcefgi

===============================
如果var s = "abacabefggeeii"
结果就不对了，结果为：abeicfgg
正则表达式的能力有限
----------------------------------------------------------

 程序代码
Function Extension(url As String) As String
Dim r As New Regex("^(?<proto>\w+)://[^/]+?(?<port>:\d+)?/", _
RegexOptions.Compiled)
Return r.Match(url).Result("${proto}${port}")
End Function


20090701更新：

超强悍的IP地址验证正则表达式：

 程序代码
^(0|[1-9]\d?|[0-1]\d{2}|2[0-4]\d|25[0-5]).(0|[1-9]\d?|[0-1]\d{2}|2[0-4]\d|25[0-5]).(0|[1-9]\d?|[0-1]\d{2}|2[0-4]\d|25[0-5]).(0|[1-9]\d?|[0-1]\d{2}|2[0-4]\d|25[0-5])$


支持n级域名判断的正则表达式：

 程序代码
^(([^-][a-z0-9A-Z-_]+\.)*)[^-][a-z0-9A-Z-_]+(\.[a-zA-Z]{2,4}){1,2}$


二级域名正则表达式 分析+分割 URL的正则表达式：

 程序代码
(\w+:\/\/)?([^\.]+)(\.[^/:]+)(:\d*)?([^# ]*)


第一个附加子表达式（$1）是用来捕获该 web 地址的协议部分。该子表达式匹配位于包括一个冒号和两个正斜杠之前的任何单词。
第二个附加子表达式（$2）捕获该地址的二级域名地址。该子表达式匹配不包括 '.' 字符的任何字符序列。
第三个附加子表达式（$3）捕获该地址的域名地址。该子表达式匹配不包括 '/' 或 ':' 字符的任何字符序列。
第四个附加子表达式（$4）捕获网站端口号码，如果指定了该端口号。该子表达式匹配后跟一个冒号的零或多个数字。
第五个附加子表达式（$5）捕获由该 web 地址指定的路径以及\或者页面信息。该子表达式匹配一个和多个除'#' 或空格之外的字符。

将该正则表达式应用于http://www.dlstu.cn:80/code/default.asp?id=1056所示的URI 后，子匹配包含如下内容：
RegExp.$0 包含 "http://www.dlstu.cn:80/code/default.asp?id=1056"
RegExp.$1 包含 "http://"
RegExp.$2 包含 "www"
RegExp.$3 包含 ".dlstu.cn"
RegExp.$4 包含 ":80"
RegExp.$5 包含 "/code/default.asp?id=1056"

超强悍的URL网址验证正则表达式，几乎可以匹配目前所有的常见网址协议，可以扩充更多以支持其他下载协议等：

 程序代码
^((https|http|ftp|rtsp|mms)?://)?(([0-9a-z_!~*'().&=+$%-]+: )?[0-9a-zA-Z_!~*'().&=+$%-]+@)?(([0-9]{1,3}\.){3}[0-9]{1,3}|([0-9a-zA-Z_!~*'()-]+\.)*([0-9a-zA-Z][0-9a-zA-Z-]{0,61})?[0-9a-z]\.[a-zA-Z]{2,6})(:[0-9]{1,4})?((/?)|(/[0-9a-zA-Z_!~*'().;?:@&=+$,%#-]+)+/?)$

-

资料引用:http://www.knowsky.com/536713.html